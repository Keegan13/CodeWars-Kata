### Вступ
Нескінченні послідовності це натуральні числа визначені таким чином, що вони завжди мають наступника. У Haskell, більшість списків часу використовуються для моделювання нескінченних послідовностей, але чому ми повинні перевіряти порожній випадок, якщо він ніколи не відбудеться?

Потоки пропонують елегантну альтернативу моделюванню нескінченних даних. Потік має головний елемент і нескінченний хвіст, на ледачих мовах це не проблема, оскільки хвіст отримує оцінку тільки в разі потреби. Але в мовах з суворою оцінкою нам потрібна лямбда-функція для затримки оцінки.

#### У C # клас Lazy використовується для моделювання запізнілих значень.

// Функція передається, але Foo ще не створено.
Lazy <Foo> lazyFoo = new Lazy <Foo> (() => новий Foo ());

// Доступ до властивості Value оцінить функцію і надасть результат.
Foo foo = lazyFoo.Value;
У чистому функціональному коді дані не мутуються. Кожна посилання незмінна. Виклик функції не змінює жодного стану і завжди має повертати одне і те ж значення.

Основи
Написати headS, яка повертає значення в голові потоку і tailS, який скидає перше значення потоку.

Нехай потоки течуть!
Імплементуйте функції для побудови потоків:

повтор повторюватиме одне і те ж значення знову і знову.
iterateS неодноразово застосовують ту ж функцію до результату останньої ітерації (починаючи з заданого значення).
cycleS повторює список назавжди.
відS буде підраховувати цифри вгору на одну.
fromStepS підраховує числа з заданою шириною кроку.
Модифікація та зменшення потоків
Для роботи з потоками, ми завжди повинні написати обчислення, яке закінчується в кінцевий час, тому ми можемо лише перевірити кінцеву частину потоку. Реалізувати загальні функції:

foldrS згортає потік з функцією зліва (результуюча структура також може бути нескінченною!).
filterS вибирає тільки ті значення, які задовольняють предикат.
takeS приймає задане число елементів з потоку.
dropS падає задане число елементів з потоку. (Підказка: не забудьте обробити негативні значення.)
Тільки Haskell: splitAtS одночасно приймає і скидає.
zipWithS об'єднує 2 потоки, застосовуючи функцію до кожної пари значень.
Реалізуйте fmap, який відображає кожне значення потоку з функцією.
Тільки Haskell: Напишіть екземпляр програми Applicative для потоків (надаються підписи типу, якщо ви не знаєте, що це означає).
До нескінченності і далі
З написаними комбінаторами ми вже можемо робити дуже корисні речі, наприклад, ми можемо писати функції, не покладаючись на небезпечні функції голови та хвоста списків.

Запис потоків для наступних послідовностей:

fibS - потік всіх номерів ребрікос (починаючи з 0).
primeS - це потік усіх простих чисел.
Підказка: Очевидне визначення primeS було б з фільтром і предикатом isPrime, хоча це звучить просто, це не найефективніше рішення (оскільки воно повинно перевести всі числа до заданого числа). Визначте спосіб зменшення кількості чисел для тестування на кожному кроці!
Vstup
Neskinchenni poslidovnosti ye zahalʹnymy, napryklad, naturalʹni chysla vyznacheni takym chynom, shcho vony zavzhdy mayutʹ nastupnyka. U Haskell, bilʹshistʹ spyskiv chasu 
rS and an isPrime predicate, while this sounds simple, it is not the most efficient solution (since it has to brute-force all numbers up to the given number). Figure out a way to reduce the amount of numbers to test in every step!